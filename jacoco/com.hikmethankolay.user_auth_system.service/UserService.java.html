<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">user-auth-system</a> &gt; <a href="index.source.html" class="el_package">com.hikmethankolay.user_auth_system.service</a> &gt; <span class="el_source">UserService.java</span></div><h1>UserService.java</h1><pre class="source lang-java linenums">/**
 * @file UserService.java
 * @brief Service class for user management.
 *
 * This class provides methods for managing users, authentication, validation, and role assignment.
 *
 * @author Hikmethan Kolay
 * @date 2025-02-12
 */

/**
 * @package com.hikmethankolay.user_auth_system.service
 * @brief Contains the core components of the User Authentication System.
 */
package com.hikmethankolay.user_auth_system.service;

import com.hikmethankolay.user_auth_system.dto.*;
import com.hikmethankolay.user_auth_system.entity.Role;
import com.hikmethankolay.user_auth_system.entity.User;
import com.hikmethankolay.user_auth_system.enums.ERole;
import com.hikmethankolay.user_auth_system.enums.TokenStatus;
import com.hikmethankolay.user_auth_system.repository.RoleRepository;
import com.hikmethankolay.user_auth_system.repository.UserRepository;
import com.hikmethankolay.user_auth_system.util.JwtUtils;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;
import jakarta.validation.Validator;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.*;

/**
 * @class UserService
 * @brief Service class for handling user-related operations.
 *
 * This service interacts with repositories to manage user authentication, validation, and user-related data.
 */
@Service
public class UserService {

    /** Repository for user data access. */
    private final UserRepository userRepository;

    /** Repository for role data access. */
    private final RoleRepository roleRepository;

    /** Password encoder for hashing user passwords. */
    private final PasswordEncoder passwordEncoder;

    /** Utility class for JWT operations. */
    private final JwtUtils jwtUtils;

    /** Validator for user input validation. */
    private final Validator validator;

    /** Login attempt service for tracking login attempts. */
    private final LoginAttemptService loginAttemptService;

    /**
     * @brief Constructor for UserService.
     * @param userRepository The user repository instance.
     * @param roleRepository The role repository instance.
     * @param passwordEncoder The password encoder instance.
     * @param jwtUtils The JWT utility instance.
     * @param validator The validator instance.
     */
<span class="fc" id="L72">    public UserService(UserRepository userRepository, RoleRepository roleRepository, PasswordEncoder passwordEncoder, JwtUtils jwtUtils, Validator validator, LoginAttemptService loginAttemptService) {</span>
<span class="fc" id="L73">        this.userRepository = userRepository;</span>
<span class="fc" id="L74">        this.roleRepository = roleRepository;</span>
<span class="fc" id="L75">        this.passwordEncoder = passwordEncoder;</span>
<span class="fc" id="L76">        this.jwtUtils = jwtUtils;</span>
<span class="fc" id="L77">        this.validator = validator;</span>
<span class="fc" id="L78">        this.loginAttemptService = loginAttemptService;</span>
<span class="fc" id="L79">    }</span>

    /**
     * @brief Retrieves all users with pagination.
     * @param pageable The pagination details.
     * @return A paginated list of users.
     */
    public Page&lt;User&gt; findAll(Pageable pageable) {
<span class="fc" id="L87">        return userRepository.findAll(pageable);</span>
    }

    /**
     * @brief Finds a user by username or email.
     * @param identifier The username or email of the user.
     * @return An Optional containing the user if found.
     */
    public Optional&lt;User&gt; findByUsernameOrEmail(String identifier) {
<span class="fc" id="L96">        return userRepository.findByUsernameOrEmail(identifier, identifier);</span>
    }

    /**
     * @brief Deletes a user by ID.
     * @param id The ID of the user to delete.
     */
    public void deleteById(Long id, Long requesterId) {
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (id.equals(requesterId)) {</span>
<span class="fc" id="L105">            throw new RuntimeException(&quot;Cannot delete your own account&quot;);</span>
        }

<span class="fc" id="L108">        User user = userRepository.findById(id)</span>
<span class="fc" id="L109">                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id &quot; + id));</span>

<span class="fc" id="L111">        userRepository.delete(user);</span>
<span class="fc" id="L112">    }</span>

    /**
     * @brief Finds a user by ID.
     * @param id The user ID.
     * @return An Optional containing the user if found.
     */
    public Optional&lt;User&gt; findById(Long id) {
<span class="fc" id="L120">        return userRepository.findById(id);</span>
    }

    /**
     * @brief Registers a new user.
     * @param userDTO The user information for registration.
     * @return The newly registered user entity.
     */
    @Transactional
    public User registerUser(UserDTO userDTO) {
        // Validate using Registration group
<span class="fc" id="L131">        Set&lt;ConstraintViolation&lt;UserDTO&gt;&gt; violations = validator.validate(userDTO, UserDTO.Registration.class);</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (!violations.isEmpty()) {</span>
<span class="fc" id="L133">            throw new ConstraintViolationException(violations);</span>
        }
        
<span class="fc" id="L136">        checkUserUniqueness(userDTO, null);</span>

<span class="fc" id="L138">        User user = new User();</span>
<span class="fc" id="L139">        user.setEmail(userDTO.getEmail());</span>
<span class="fc" id="L140">        user.setUsername(userDTO.getUsername());</span>
<span class="fc" id="L141">        user.setPassword(passwordEncoder.encode(userDTO.getPassword()));</span>

        // Assign default role
<span class="fc" id="L144">        assignRoleToUser(user, ERole.ROLE_USER);</span>

<span class="fc" id="L146">        return userRepository.save(user);</span>
    }

    /**
     * @brief Authenticates a user.
     * @param loginRequest The login request containing username or email and password.
     * @param clientIp The client IP for rate limiting.
     * @return A JWT token if authentication is successful, otherwise null.
     * @throws RuntimeException if the account or IP is blocked due to too many failed login attempts.
     */
    public String authenticateUser(LoginRequestDTO loginRequest, String clientIp) {
<span class="fc" id="L157">        String identifier = loginRequest.identifier();</span>

        // Check if the IP address is blocked due to too many failed login attempts
<span class="fc bfc" id="L160" title="All 2 branches covered.">        if (loginAttemptService.isBlocked(clientIp)) {</span>
<span class="fc" id="L161">            throw new RuntimeException(&quot;Too many failed login attempts from this IP. Please try again later.&quot;);</span>
        }

        // Check if the user is blocked due to too many failed attempts
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (loginAttemptService.isBlocked(identifier)) {</span>
<span class="fc" id="L166">            throw new RuntimeException(&quot;Account is temporarily locked due to too many failed login attempts. Please try again later.&quot;);</span>
        }

<span class="fc" id="L169">        Optional&lt;User&gt; user = userRepository.findByUsernameOrEmail(identifier, identifier);</span>

<span class="pc bpc" id="L171" title="1 of 4 branches missed.">        if (user.isPresent() &amp;&amp; passwordEncoder.matches(loginRequest.password(), user.get().getPassword())) {</span>
            // Authentication successful - reset failed attempts counter
<span class="fc" id="L173">            loginAttemptService.loginSucceeded(clientIp);</span>
<span class="fc" id="L174">            loginAttemptService.loginSucceeded(identifier);</span>

<span class="fc" id="L176">            return jwtUtils.generateJwtToken(</span>
<span class="fc" id="L177">                    String.valueOf(user.get().getId()),</span>
<span class="fc" id="L178">                    user.get().getUsername(),</span>
<span class="fc" id="L179">                    loginRequest.rememberMe()</span>
            );
        } else {
            // Authentication failed - increment failed attempts counter
<span class="fc" id="L183">            loginAttemptService.loginFailed(clientIp);</span>
<span class="fc" id="L184">            loginAttemptService.loginFailed(identifier);</span>
<span class="fc" id="L185">            return null;</span>
        }
    }

    /**
     * @brief Refreshes an authentication token.
     * @param token The current token to refresh.
     * @return A new JWT token if refresh is successful, otherwise null.
     */
    public String refreshToken(String token) {
<span class="pc bpc" id="L195" title="1 of 4 branches missed.">        if (token != null &amp;&amp; jwtUtils.validateJwtToken(token) != TokenStatus.INVALID) {</span>
            try {
<span class="fc" id="L197">                Long userId = jwtUtils.getUserIdFromJwtToken(token);</span>
<span class="fc" id="L198">                Optional&lt;User&gt; userOpt = findById(userId);</span>

<span class="fc bfc" id="L200" title="All 2 branches covered.">                if (userOpt.isPresent()) {</span>
<span class="fc" id="L201">                    User user = userOpt.get();</span>
<span class="fc" id="L202">                    boolean wasRememberMe = jwtUtils.wasRememberMe(token);</span>

<span class="fc" id="L204">                    return jwtUtils.generateJwtToken(</span>
<span class="fc" id="L205">                            String.valueOf(user.getId()),</span>
<span class="fc" id="L206">                            user.getUsername(),</span>
                            wasRememberMe
                    );
                }
<span class="nc" id="L210">            } catch (Exception e) {</span>
                // Token processing failed
<span class="nc" id="L212">                return null;</span>
<span class="fc" id="L213">            }</span>
        }
<span class="fc" id="L215">        return null;</span>
    }

    /**
     * Updates a user using the provided update DTO, applying only non-null fields.
     * Validates the update data and ensures username/email uniqueness.
     *
     * @param updates DTO with update data (must not be null)
     * @param id the ID of the user to update
     * @return the updated User
     * @throws IllegalArgumentException if updates is null
     * @throws RuntimeException if the user is not found or uniqueness checks fail
     */
    @Transactional
    public User updateUser(UserDTO updates, Long id, Long requesterId) {
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        if (updates == null) {</span>
<span class="nc" id="L231">            throw new IllegalArgumentException(&quot;Updates cannot be null&quot;);</span>
        }

        // Validate using Update group
<span class="fc" id="L235">        Set&lt;ConstraintViolation&lt;UserDTO&gt;&gt; violations = validator.validate(updates, UserDTO.Update.class);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (!violations.isEmpty()) {</span>
<span class="fc" id="L237">            throw new ConstraintViolationException(violations);</span>
        }

<span class="fc" id="L240">        checkUserUniqueness(updates, id);</span>

<span class="fc" id="L242">        User user = userRepository.findById(id)</span>
<span class="fc" id="L243">                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with id: &quot; + id));</span>

<span class="fc" id="L245">        User requester = userRepository.findById(requesterId)</span>
<span class="fc" id="L246">                .orElseThrow(() -&gt; new RuntimeException(&quot;Requester not found with id: &quot; + requesterId));</span>

<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        boolean isAdminAction = requester.getRole() != null &amp;&amp; </span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">                requester.getRole().getName().equals(ERole.ROLE_ADMIN);</span>

<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        if (StringUtils.hasText(updates.getUsername())) {</span>
<span class="fc" id="L252">            user.setUsername(updates.getUsername().trim());</span>
        }

<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (StringUtils.hasText(updates.getEmail())) {</span>
<span class="fc" id="L256">            user.setEmail(updates.getEmail().trim());</span>
        }

<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (StringUtils.hasText(updates.getPassword())) {</span>
<span class="fc" id="L260">            user.setPassword(passwordEncoder.encode(updates.getPassword().trim()));</span>
        }

<span class="pc bpc" id="L263" title="3 of 4 branches missed.">        if (updates.getRole() != null &amp;&amp; isAdminAction) {</span>
<span class="nc" id="L264">            assignRoleToUser(user, updates.getRole());</span>
        }

<span class="fc" id="L267">        return userRepository.save(user);</span>
    }

    /**
     * Validates user uniqueness (username and email).
     *
     * @param userDTO the user DTO to validate
     * @param userId the ID of the user (to exclude self-check)
     * @throws RuntimeException if username or email is already taken
     */
    private void checkUserUniqueness(UserDTO userDTO, Long userId) {
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (userDTO.getUsername() != null) {</span>
<span class="fc" id="L279">            userRepository.findByUsername(userDTO.getUsername())</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">                    .filter(user -&gt; !Objects.equals(user.getId(), userId))</span>
<span class="fc" id="L281">                    .ifPresent(user -&gt; { throw new RuntimeException(&quot;Username is already taken!&quot;); });</span>
        }

<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        if (userDTO.getEmail() != null) {</span>
<span class="fc" id="L285">            userRepository.findByEmail(userDTO.getEmail())</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">                    .filter(user -&gt; !Objects.equals(user.getId(), userId))</span>
<span class="fc" id="L287">                    .ifPresent(user -&gt; { throw new RuntimeException(&quot;Email is already taken!&quot;); });</span>
        }
<span class="fc" id="L289">    }</span>

    /**
     * @brief Assigns a role to a user.
     * @param user The user to whom the role will be assigned.
     * @param roleName The role to assign.
     */
    private void assignRoleToUser(User user, ERole roleName) {
<span class="fc" id="L297">        Optional&lt;Role&gt; role = roleRepository.findByName(roleName);</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (role.isPresent()) {</span>
<span class="fc" id="L299">            user.setRole(role.get());</span>
        } else {
<span class="nc" id="L301">            throw new RuntimeException(&quot;Role not found with name: &quot; + roleName);</span>
        }
<span class="fc" id="L303">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>